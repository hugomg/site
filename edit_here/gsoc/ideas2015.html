
<h2>Ideas' List - Google Summer of Code 2015</h2>

<ul>
<li><a href="#luarocks">
LuaRocks add-ons system
</a></li>
<li><a href="#kerneltest">
Port Lua Test Suite to NetBSD Kernel
</a></li>
<li><a href="#elastic">
Elasticsearch Lua client (elasticsearch-lua)
</a></li>
<li><a href="#lpeg">
Add support for left recursion to LPeg
</a></li>
<li><a href="#typed">
Switch Typed Lua from optional typing to gradual typing
</a></li>
<li><a href="#cgilua">
Adapt CGILua SAPI launcher to explore all WSAPI features
</a></li>
<li><a href="#luasoap">
Add support for WSDL generation to LuaSOAP
</a></li>
<li><a href="#luasql">
Add support for prepared statements in LuaSQL
</a></li>
<li><a href="#vlc">
Multi-CPU usage in VLC
</a></li>
<li><a href="#wireshark">
Multi-CPU usage in wireshark
</a></li>
<li><a href="#dynserial">
Develop a binary serialization format with support for dynamically types values and an RPC protocol for dynamically typed invocations based on this format.
</a></li>
<li><a href="#loski">
Develop a library for Lua that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.
</a></li>
</ul>

<br><hr>
<h3 id="luarocks">LuaRocks add-ons system</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://luarocks.org">LuaRocks</a>
is a package manager for
Lua modules. Since version 1.0, the format of the package
specification file (rockspec) was unchanged, in the name of
compatibility. For the next major release of LuaRocks, we intend to
make a backward-compatible revision to the format. However, instead of
guessing which features will be needed in the forthcoming years, the
idea is to make the format extensible through <i>add-ons</i>, as
discussed in this <a
href="https://www.youtube.com/watch?v=WiZqfpZLSA8">Lua Workshop 2014
talk</a>.

<p>There are two sides to making an application extensible: defining
hooks to the application where extensions will plug into, and defining
a public API, which is the parts of the application that the
extensions will see/access.

<p>This includes major design work, and the student is not expected to do
this alone: the design part will be discussed with the mentor and the
LuaRocks community at large through the <a
href="https://lists.sourceforge.net/lists/listinfo/luarocks-developers">LuaRocks
mailing list</a>. The coding part, of course, is up to the student.

<p>The best way to evaluate new APIs is to put them to work: the second
phase of the project will be to write some add-ons, to exercise the
new features. Two features that are often requested by the community
are support for running tests and generating documentation files:
these would make great add-ons.

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Extending the LuaRocks rockspec reader to allow new entries
created by add-ons</li>
<li>A system of hooks in LuaRocks to trigger actions programmed by add-ons</li>
<li>A sandbox environment for presenting a restricted API to add-ons</li>
<li>Add-ons for running tests and generating documentation</li>
</ul>


<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>Lua - comfortable writing code for Lua 5.x (LuaRocks runs in Lua
5.1-5.3)</li>
<li>LuaRocks - experience with writing rockspecs (if you never wrote
any, pick a module that's not yet available in the LuaRocks repository
and give it a try!)</li>
<li>Git (experience with the Github workflow is a bonus)
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<a href="http://hisham.hm/">Hisham Muhammad</a>
<p>
<br><hr>
<h3 id="kerneltest">Port Lua Test Suite to NetBSD Kernel</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p>
<a href="http://www.netbsd.org">The NetBSD Operating System</a>
has a kernel-level Lua interpreter version for
<a href="http://netbsd.org/~lneto/dls14.pdf">scripting its kernel</a>.
For example, it allows users to
<a href="http://netbsd.org/~lneto/eurobsdcon14.pdf">filter packets using Lua
scripts</a>.
<p>
The main difference between kernel Lua and regular user-level Lua
is that kernel Lua doesn't have support for standard libraries that depend on
operating system (e.g., io and os) and for floating-point numbers.
The purpose of this project is to port
the <a href="http://www.lua.org/tests/">Lua Test Suite</a>
to NetBSD kernel.
That is,
to adapt scripts from Lua test suite and
develop a <a
href="http://www.home.unix-ag.org/bmeurer/NetBSD/howto-lkm.html">NetBSD
loadable kernel module</a> containing the C portion of Lua test suite.

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Adapted test scripts for kernel Lua</li>
<li>Kernel module for testing the
<a href="http://www.lua.org/manual/5.3/manual.html#4">Lua C API</a></li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>C, Lua (and some patience :) )
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<a href="mailto:lourival.neto@gmail.com">Lourival Vieira Neto</a>
<p>
<br><hr>
<h3 id="elastic">Elasticsearch Lua client (elasticsearch-lua)</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://elasticsearch.com/">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to
Java), it offers a very complete REST API accessed through
<a href="http://json.org/">JSON</a></p>

<p>Elasticsearch clients for different scripting languages such as Python, PHP
and Perl have already been developed.
However, a client for <a href="http://lua.org/">Lua</a>
is still not available.

<p>This project aims to create a complete Lua client to access Elasticsearch.


<h4 id="expectedresults">Expected results</h4>
<ul>
<li>A complete Lua client to access the Elasticsearch REST API.
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>Lua - medium (socket and metatable experience is important)
<li>Elasticsearch - basic/medium
<li>JSON - medium
<li>HTTP - basic/medium
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<p>
<br><hr>
<h3 id="typed">Switch Typed Lua from optional typing to gradual typing</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="https://github.com/andremm/typedlua">Typed Lua</a>
is an optional type system for Lua, and its main goal is to
provide static type checking for Lua.
To do that, Typed Lua extends the syntax of Lua 5.3 to introduce
optional type annotations, and performs local type inference
to detect more precise types for unannotated expressions.
Even though the compiler warns the programmer about type errors,
it always removes the type annotations to generate Lua code that
runs in unmodified Lua implementations, and this code does not
insert any run-time checks that ensure safety between dynamically
typed and statically typed code.

<h4 id="expectedresults">Expected results</h4>
The aim of this project is to make the Typed Lua compiler insert
run-time checks in the
<a href="http://wphomes.soic.indiana.edu/jsiek/what-is-gradual-typing/">
gradual typing</a> style.
These run-time checks are assertions that inspect the interaction
between dynamically typed and statically typed code to guarantee
that dynamically typed code does not violate statically typed code.
We also expect an evaluation of these run-time checks to identify
what is the overhead that they introduce in the execution
of the generated code.

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>Lua and Type Systems

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>
<p>André Murbach Maidl</p>



<br><hr>
<h3 id="cgilua">Adapt CGILua SAPI launcher to explore all WSAPI features.</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://keplerproject.github.io/cgilua/">
CGILua</a> is a tool for creating dynamic Web pages and manipulating input
data from Web forms.  One of advantages of CGILua is its abstraction
of the underlying Web server. CGILua can be used with a variety of Web
servers and, for each server, with different launchers. A launcher is
responsible for the interaction of CGILua and the Web server, for example
using ISAPI on IIS or mod_lua on Apache. The reference implementation
of CGILua launchers is Kepler.</p>

<p> <a href="http://keplerproject.github.io/wsapi/">WSAPI</a>
is an API that abstracts the web server from Lua web
applications. WSAPI provides a set of helper libraries that help with
request processing and output buffering.</p>

<p>Actually CGILua has an implementation of an abstract underlying server
which is almost the same of WSAPI itself. This project proposes a
reimplementation of this layer (called SAPI) to explore WSAPI fully. This
should improve the performance and simpify maintenance.</p>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Rewrite CGILua library to dispense SAPI module and use WSAPI directly.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>Advanced Lua programming is mandatory, since both tools (CGILua and WSAPI)
are not naive software. A good understanding of the Lua environment
concept is particularly necessary in this project.</p>

<p>Web programming experience can be very helpful especially to understand
the context of use of these tools.</p>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<p>Tomás Guisasola</p>

<br><hr>
<h3 id="luasoap">Add support for WSDL generation to LuaSOAP</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://tomasguisasola.github.io/luasoap/">LuaSOAP</a> is a library to
ease the use of <a href="http://www.w3.org/TR/soap/">SOAP</a>.  LuaSOAP provides
a very simple API that convert Lua tables to and from XML documents.
It also offers a simple way to invoke remote Web Services without having
to deal directly with SOAP messages.  In fact, LuaSOAP also provides
a simple way to offer Web Services -- the server side -- but it lacks
support for WSDL generation of the offered services.</p>

<p><a href="http://www.w3.org/TR/wsdl">WSDL</a> is an XML format for describing
network services.  It is used to describe operations and messages --
with its types -- offered by Web Services.  Since Lua code does not
include type information, automatic generation has to be based on some
kind of hand-made declarative information.</p>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Define the format to describe complementary WSDL information in Lua</li>
<li>Implement an automatic generator of WSDL documents</li>
<li>Test and document everything</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>Lua programming; client-server web architecture; SOAP and WSDL specifications.</p>

<ul>
<li>Basic programming in Lua is mandatory</li>
<li>Web programming experience is very appreciated but not mandatory</li>
<li>SOAP and WSDL specifications could be learned during the project</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Tomás Guisasola</p>

<br><hr>
<h3 id="luasql">Add support for prepared statements in LuaSQL</h3>
<h4 id="briefexplanation">Brief explanation</h4>
<p><a href="http://www.keplerproject.org/luasql/">
LuaSQL</a> is a generic interface from Lua to a DBMS.
It aims at portability over performance, but it allows extensions to
suit the particularities of each DBMS.</p>

<p>The inclusion of support for prepared statements in LuaSQL has been
discussed thoroughly some time ago, but since each DBMS offers very
different APIs there is no standard that could be defined to assure
portability between them.
Anyway the demand persists.</p>

<p>This project proposes the addition of a minimal API that would allow
each driver to implement prepared statements according to its DBMS
restrictions.</p>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Adapt the API to each LuaSQL driver according to its particularities</li>
<li>Implement the new functions to each driver</li>
<li>Test and document everything</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>C, Lua and C API for Lua:</p>

<ul>
<li>C is mandatory.</li>
<li>Knowledge of the C API for Lua is mandatory, although it is not too
difficult to be learned during the project.</li>
<li>Basic programming in Lua is very helpful, but not mandatory, since
the examples and test-cases are very simple.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>
<p>Tomás Guisasola</p>

<br><hr>
<h3 id="vlc">Multi-CPU usage in VLC</h3>
<h4 id="briefexplanation">Brief explanation:</h4>

<p><a href="https://wiki.videolan.org/VLC_media_player/">VLC </a> is a free and open source cross-platform multimedia player and framework that plays most multimedia files as well as DVD, Audio CD, VCD, and various streaming protocols. Lua scripts can be added to VLC for tasks such as playlist construction and service discovery. Such tasks may involve a lot of parsing and communication and could benefit from using multiple CPUs when available. The purpose of this project is to include support for multi-CPU usage in VLC, using
<a href="http://askyrme.github.io/luaproc/">luaproc</a>,
 a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4 id="expectedresults">Expected results:</h4>
<p>Multi-CPU support in VLC.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>
<p>C, Lua</p>

<h4 id="skilllevel">Skill level:</h4>
<p>Medium</p>

<h4 id="mentor">Mentor:</h4>
<p>Alexandre Skyrme</p>

<br><hr>
<h3 id="wireshark">Multi-CPU usage in wireshark</h3>
<h4 id="briefexplanation">Brief explanation:</h4>

<p>The 
<a href="http://www.wireshark.org/">
wireshark network protocol analyser</a> allows programmers to use Lua to write dissectors, post-dissectors and taps. Dissectors are protocol analysers, while post-dissectors are executed after all others dissectors, and taps are used to collect information after packet dissection. Protocol dissection can involve time constraints, and it would be nice to benefit from multi-CPU processing power in dissector script. The purpose of this project is to include support for multi-CPU usage in wireshark, using 
<a href="http://askyrme.github.io/luaproc/">luaproc</a>,
a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4 id="expectedresults">Expected results:</h4>
<p>We expect the support for Multi-CPU usage in wireshark.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>
<p>C, Lua</p>

<h4 id="skilllevel">Skill level:</h4>
<p>Medium</p>

<h4 id="mentor">Mentor:</h4>
<p>Alexandre Skyrme</p>


<br><hr>
<h3 id="lpeg">Add support for left recursion to 
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/">
LPeg</a></h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p>Parsing Expression Grammars (PEGs) are an expressive formalism for designing
and implementing top-down parsers with local backtracking. A frequently missed 
feature of PEGs is left recursion, which is commonly used in 
Context-Free Grammars (CFGs) to encode left-associative operations.

<p>There is a 
<a href="http://arxiv.org/pdf/1207.0443.pdf">
formal extension to the PEGs formalism</a>
that allows the use of 
left-recursive rules in a PEG grammar and that was implemented by 
some PEG-based tools, such as
<a href="https://github.com/sacek/LPegLJ">LPegLJ  </a>
and <a href="http://ironmeta.sourceforge.net/">IronMeta</a>.

<p>The aim of this project is to create a fork of
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a>,
an implementation of PEGs for Lua based on a virtual parsing machine.

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>C, Lua and Parsing Expression Grammars

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>
<p><a href="https://sites.google.com/site/sqmedeiros/">Sérgio Medeiros</a></p>

<br><hr>
<h3 id="dynserial">Develop a binary serialization format with support for dynamically types values and an RPC protocol for dynamically typed invocations based on this format.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Most RMI protocols available today are either focused on inefficient 
representation formats for typing information (e.g.
<a href="http://www.omg.org/spec/CORBA/3.3/Interoperability/PDF">
GIOP/IIOP (CORBA)</a>,
<a href="http://hessian.caucho.com">Hessian</a>,
<a href="https://developers.google.com/protocol-buffers/">
Google Protocol Buffers</a>)
or on invocations where the typing information are predefined and static, 
therefore are absent on the data sent through the wire 
(e.g.
<a href="http://www.w3.org/TR/soap/">SOAP</a>,
<a href="http://www.json.org">JSON</a>,
<a href="http://www.caucho.com/resin-3.0/protocols/burlap.xtp">Burlap</a>).
<p>
Few protocols are designed to work efficiently with typed data. Invocations with typed data work well with the RPC model because it allows the identification of deployment problems (mismatch interfaces) and facilitate the dynamic evolution of distributed systems. A protocol for dynamically typed RPC should be based on a efficient serialization format for typed data, that is, information about how the data should be interpreted.</p>

<p>The goal of this project is to design and implement a serialization binary serialization format with the following requirements:</p>

<ul>
<li>Primitive data: numeric formats (integer and floating-point), characters and boolean.</li>
<li>Structured data: serialization of usual structured data like records, arrays, maps, tuples, union, etc.</li>
<li>Optional typing: serialization of both raw data and data plus typing information.</li>
<li>Structural compatibility: type information should allow to efficiently verify whether two types are compatibile.</li>
<li>Opaque data: allow that a special form of raw data (without typing information) can be ignored without compromising the remains of the stream and that can also be passed along by a receiver that did not interpreted it.</li>
<li>Semantic information: data types that can extend a standard type with additional semantic information, like a string (sequence of characteres) with an associated charset or a record with an associated class name that provides some behavior over the data on the record.</li>
<li>Graphs: data with cyclic references.</li>
</ul>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>An specification of a binary serialization format with support for typed data.</li>
<li>An implementation of a library for encoding values using this format.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
<li>Programming in C (medium to advanced).</li>
<li>Familiarity with concepts of the Lua language.</li>
<li>Data structures and formats (endianess, two's complement, IEEE 754, memory pointes, etc).
<li>Network protocols fundamentals.
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Renato Maia</p>

<br><hr>
<h3 id="loski">Develop a library for Lua 
that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.</h3>

<h4 id="briefexplanation">Brief explanation</h4>
<p>Standard Lua distribution is based mostly on standard ANSI C libraries only. Therefore, many functionalities provided by modern platforms (like process control, file system operations, network communication, kernel event notification, etc.) are only available through third-party libraries that are developed independently and might not integrate.</p>

<p>The project has three main goals:</p>

<ul>
<li>Design a simple and easy API that allows for different implementations over various platforms (POSIX, Linux, MacOSX, Windows, etc.) yet allowing use of a basic set of features that are provided by most popular plataforms.</li>
<li>Design an internal architecture that facilitate the replacement of the actual implementation of the features provided by the library (create process, use sockets, inspect file systems, etc). This is important to make porting the library to other platoforms easier.</li>
<li>Provide a basic/standard implementation of features provided by the library based on the codebase of existing Lua libraries that already export features of the underlying platform like 
<a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a>,
<a href="http://keplerproject.github.io/luafilesystem/">
LuaFileSystem</a> and others.</li>
</ul>

A prototype for the proposed library is available 
<a href="https://github.com/renatomaia/loski">
here</a>.

<h4 id="expectedresults">Expected results</h4>

<p>A set of Lua libraries implemented at least in one major operating system platform. The library shall provide support for:</p>

<ul>
<li>Creation and manipulation of processes, and possibly inter-process comunication mechanisms, such as pipes.</li>
<li>Creation and maniputation of sockets (TCP and UDP).</li>
<li>Inspection of the local file system, possibly including file attributes and permissions.</li>
<li>Notification of kernel events like process termination, socket data availability, file modification, etc.</li>
</ul>

<p>The implementation shall also be flexible enough to facilitate the portability for other platforms.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>Programming in C.</li>
<li>Familiarity with concepts of the Lua language.</li>
<li>Programming with the system API of some popular platform, such as Linux, FreeBSD, Windows, etc.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Renato Maia</p>

