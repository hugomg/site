
<h2>Ideas List - Google Summer of Code 2016</h2>

<ul>
<li><a href="#elasticsearch_update">
Update elasticsearch-lua
</a></li>
<li><a href="#elasticsearch_sailor">
Elasticsearch and Sailor
</a></li>
<li><a href="#elasticsearch_tests">
Improve elasticsearch-lua tests and build
</a></li>
<li><a href="#libscript">
Enhancements to LibScript, a cross-language scripting library
</a></li>
<li><a href="#typed">
Implement core Typed Lua in Haskell
</a></li>
<li><a href="#ceu">
Extending the online tutorial of Céu with Emscripten and SDL
</a></li>
<li><a href="#netbsd">
Develop I/O API for NetBSD Kernel Lua
</a></li>
<li><a href="#cgilua">
Adapt CGILua SAPI launcher to explore all WSAPI features
</a></li>
<li><a href="#luasql">
Add support for prepared statements in LuaSQL
</a></li>
<li><a href="#peg">
Improving the Quality of Error Messages in PEG Parsers
</a></li>
<li><a href="#lad">
Assembler and Disassembler for Lua 5.3
</a></li>
<li><a href="#typedlua">
Add class-based object-oriented programming to Typed Lua
</a></li>
</ul>

<br><hr>
<h3 id="elasticsearch_update">Update elasticsearch-lua</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to Java), it
offers a very complete REST API accessed through <a href="http://json.org/">JSON</a>.
<a href="https://github.com/DhavalKapil/elasticsearch-lua/">elasticsearch-lua</a>
is a Lua library that allows Lua applications to easily comunicate with
Elasticsearch clusters.
</p>

<p>Currently, elasticsearch-lua is built on top of Elasticsearch 1.7 but does not implement all possible Elasticsearch features. Moreover, Elasticsearch is already in version 2.2 and many new features are available.</p>

<p>This project aims to implement the missing features from 1.7 and also add the new features from Elasticsearch 2.2.</p>

<h4>Expected results</h4>

<p>
An updated Lua client to access the Elasticsearch REST API compatible with the latest version (currently 2.2).
</p>

<h4>Knowledge prerequisites</h4>

<p>
<ul>
<li>Lua - medium</li>
<li>JSON - medium</li>
<li>HTTP - medium</li>
<li>Elasticsearch - medium</li>
</ul>
</p>

<h4>Skill level</h4>
<p>Medium</p>

<h4>Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<br><hr>
<h3 id="elasticsearch_sailor">Elasticsearch and Sailor</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to Java), it
offers a very complete REST API accessed through <a href="http://json.org/">JSON</a>.
<a href="https://github.com/DhavalKapil/elasticsearch-lua/">elasticsearch-lua</a>
is a Lua library that allows Lua applications to easily communicate with
Elasticsearch clusters.
</p>

<p>
<a href="http://sailorproject.org/">Sailor</a> is a web framework in the Lua programming language. Like Lua, it is open sourced under the MIT License, which is extremely permissive. Sailor applications are structured in a model-view-controller (MVC) architecture.
</p>

<p>
This project aims the development of a search module that integrates elasticsearch-lua into Sailor.
</p>

<h4>Expected results</h4>

<p>
A search functionality that is easy to use and integrate to a website using Sailor. Internally,
a new form.search method in the form module that exposes a search text input and a search model similar to the current database one. 
</p>

<h4>Knowledge prerequisites</h4>

<p>
<ul>
<li>Lua - medium</li>
<li>Sailor - not required</li>
<li>Elasticsearch - basic</li>
<li>Web Development - medium</li>
</ul>
</p>

<h4>Skill level</h4>
<p>Easy/Medium</p>

<h4>Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<br><hr>
<h3 id="elasticsearch_tests">Improve elasticsearch-lua tests and build</h3>

<h4>Brief explanation</h4>

<p>
<a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to Java), it
offers a very complete REST API accessed through <a href="http://json.org/">JSON</a>.
<a href="https://github.com/DhavalKapil/elasticsearch-lua/">elasticsearch-lua</a>
is a Lua library that allows Lua applications to easily comunicate with
Elasticsearch clusters.
</p>

<p>
Currently, elasticsearch-lua has small build automation, only 19 library tests and no code coverage.
</p>

<p>This project aims to implement more robust build automation.</p>

<h4>Expected results</h4>

<p>
An integration for code coverage, automated build tests (already working) and a large set of tests that cover most part of the code.
</p>

<h4>Knowledge prerequisites</h4>

<p>
<ul>
<li>Lua - basic</li>
<li>Elasticsearch - basic/medium</li>
<li>Continous Integration - basic</li>
</ul>
</p>

<h4>Skill level</h4>
<p>Easy</p>

<h4>Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>

<br><hr>
<h3 id="libscript">Enhancements to LibScript, a cross-language scripting library</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://libscript.sf.net">LibScript</a>
is a library for cross-language scripting: it allows code written in one scripting
language to call function written in a different language, and allows C programs
to support various scripting languages via a single interface. LibScript currently
supports Python, Ruby, Lua and Perl, and it only supports passing simple values
as arguments (strings, numbers, booleans).</p>

<p>This project has two goals:</p>

<ul>
<li>supporting a wider set of functions - support passing and receiving structured
data types such as lists and dictionaries. An idea of how to do this to pass data
by-copy, using JSON as an interchange format between languages.</li>
<li>supporting more languages - two languages that would be useful to support would
be JavaScript (writing a LibScript plugin that links the V8 virtual machine),
and <a href="https://www.r-project.org">R</a> (giving many languages access to the vast array of statistical
libraries available in <a href="http://cran.us.r-project.org/">CRAN</a>).</li>
</ul>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Enhancements to the existing LibScript plugins, supporting structured data types.</li>
<li>New plugins supporting additional languages</li>
</ul>


<h4>Knowledge prerequisites</h4>
<ul>
<li>C programming - must be comfortable with C code, working with C libraries and learning their APIs</li>
<li>Unix shell and tools - Makefile, shell scripting (not being scared of <a href="http://www.sourceware.org/autobook/">Autotools</a> is a bonus -- if scared, we'll work on it!)</li>
<li>Previous experience in some scripting language - any of Python, Ruby, Lua, Perl, JavaScript, etc.</li>
<li>Git (experience with the Github workflow is a bonus)</li>
<li>Previous experience embedding any scripting language in a C application is a bonus</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Medium/advanced</p>

<h4 id="mentor">Mentor</h4>
<p>
<a href="http://hisham.hm/">Hisham Muhammad</a>
</p>

<br><hr>
<h3 id="typed">Implement core Typed Lua in Haskell</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="https://github.com/andremm/typedlua">Typed Lua</a>
is an optional type system for Lua, and its main goal is to
provide static type checking for Lua.
To do that, Typed Lua extends the syntax of Lua 5.3 to introduce
optional type annotations, and performs local type inference
to detect more precise types for unannotated expressions.
</p>

<p>The aim of this project is to implement core Typed Lua in Haskell,
as a tool to test new features and reason about new typing rules for Typed Lua.
Core Typed Lua limits control flow to if and while statements;
it has explicit type annotations, explicit scope for variables,
explicit method declarations, and explicit method calls.
</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>A type checker written in Haskell that analyses code written in core Typed Lua.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
<li>Lua (for understanding regular Typed Lua implementation).</li>
<li>Haskell (for implementing the project).</li>
<li>Type Systems (for understanding the typing rules).</li>
<li>Git (the project repository should be in github).</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Advanced</p>

<h4 id="mentor">Mentor</h4>
<p>
<a href="mailto:amaidl@inf.puc-rio.br">André Murbach Maidl</a>
</p>

<br><hr>
<h3 id="ceu">Extending the online tutorial of Céu with Emscripten and SDL</h3>

<h4>Brief explanation</h4>

<p><a href="http://ceu-lang.org/">Céu</a> is a programming language that targets system-level development of reactive systems. The language is under development at the LabLua since 2011. For a little introduction about Céu, please watch the video in <a href="http://ceu-lang.org/">our front page</a>. Céu appeared in <a href="http://www.future-programming.org/2014/program.html">Future Programming</a> and <a href="http://curry-on.org/2015/sessions/structured-synchronous-programming.html">Curry-On</a> workshops.</p>

<p>Currently, the online tutorial of Céu executes a simulation at the server side:</p>

<a href="http://ceu-lang.org/try.php">http://ceu-lang.org/try.php</a>

<p>The tutorial works as follows:</p>

<ol>
<li>User reads about a new concept (`top/left` of the page).</li>
<li>User reads an accompanying example (`top/right`) with an input (`bottom/right`).</li>
<li>User clicks "Run" (`top/right`)
<ol>
    <li>Code is sent to the server.</li>
    <li>Server compiles and executes the code with the provided input.</li>
    <li>User gets an output (`bottom/left`).</li>
</ol>
<li>User changes the code and input to experiment with it (going to step 3).</li>
<li>User advances in the tutorial.</li>
</ol>

<p>
The server-side approach does not provide a reactive and real-time experience, 
which are the ultimate objectives of the language. We want the online tutorial to offer a more interactive experience for learners 
of Céu. The client-side tutorial would work as follows:
</p>

<ol>
<li>User reads about a new concept (`top/left` of the page).
<li>User sees an example (`top/right`) <strike>with an input (`bottom/right`)</strike>.
<li>User clicks "Run" (`top/right`):
<ol>
    <li>Code is sent to the server.
    <li>Server compiles the code <strike>with the provided input</strike> to Javascript and 
       returns it to the client.
    <li>User <strike>gets an output (`bottom/left`)</strike> interacts with the program in 
       real time.
</ol>
<li>User changes the code <strike>and input</strike> to experiment with it (going to step 3).
<li>User advances in the tutorial.
</ol>

<h4>Tools</h4>

<p>
<a href="http://libsdl.org/">SDL</a> is a C-based and cross-platform development library that provides access to 
audio, keyboard, mouse, joystick, and graphics hardware.
Given that Céu interacts well with C, combining Céu and SDL is a viable option 
for building a visually-appealing interactive tutorial.
<a href="https://github.com/kripken/emscripten/">Emscripten</a> is an LLVM-to-JavaScript compiler. SDL has already <a href="https://github.com/kripken/emscripten/issues/2404">been ported to Emscripten</a>.
</p><p>
Putting it all together, we can build an interactive tutorial for Céu that runs 
in the browser at the client side.
</p><p>
The bulk of the project is to implement this synergy between C, Céu, SDL, and 
Emscripten.
However, the project also involves other tools: Linux, Git, HTML and PHP.
</p>

<h4>Expected results</h4>

<ul><li>A working interactive online tutorial for Céu.</ul>

<p>
As an ultimate goal, we would like to build an incremental tutorial based on 
<a href="https://vimeo.com/110512582">this video</a>.

<h4>Prerequisites</h4>

<p>
We expect the applicants to know <b>C</b> well and to develop minimum familiarity 
with the important tools before the project kicks off.
</p><p>
For this reason, we will ask the applicants to perform two activities *before* 
the application period:
</p>
<ol>
<li>Create a repository on *Github* and write a simple "Hello World" page using
   Emscripten and SDL.
<li>Install Céu and compile some existing SDL examples (without Emscripten).
</ol>

<p>
Both activities should be simple, i.e., nothing more than following tutorials 
on the web.
</p>

<h4>How to apply</h4>

<ul>
<li><a href="https://gitter.im/fsantanna/ceu-gsoc-2016">Get in touch</a>
<li>Follow the official GSoC instructions.
<li>Follow the LabLua instructions.
</ul>

<h4>Skill level</h4>

<p>
Medium
</p>

<h4>Mentor</h4>

<p>
<a href="http://www.ceu-lang.org/chico">Francisco Sant'Anna</a>
</p>

<br/><hr/>

<h3 id="netbsd">Develop I/O API for NetBSD Kernel Lua</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://www.netbsd.org">The NetBSD Operating System</a> has a
kernel-level Lua interpreter version for
<a href="http://netbsd.org/~lneto/dls14.pdf">scripting its kernel</a>.
For example, it allows users to
<a href="http://netbsd.org/~lneto/eurobsdcon14.pdf">filter packets
using Lua scripts</a>.
</p>
<p>
The main difference between kernel Lua and regular user-level Lua is
that kernel Lua doesn't have support for standard libraries that
depend on operating system (e.g., io and os) and for floating-point
numbers. The purpose of this project is to develop kernel Lua
libraries to provide I/O functionality to kernel scripts. This API
should provide access both for file system and network. It should be
implemented as
<a href="http://www.home.unix-ag.org/bmeurer/NetBSD/howto-lkm.html">NetBSD
loadable kernel modules</a> binding the kernel internal implementation
for files and sockets user-level API.
</p>

<h4>Expected results</h4>

<ul>
<li>Kernel Lua File Library</li>
<li>Kernel Lua Socket Library</li>
<li>Documentation and Benchmarks</li>
</ul>

<h4>Knowledge prerequisites</h4>

<p>
C, Lua, OS  (and some courage :) )
</p>

<h4>Skill level</h4>

<p>
Advanced
</p>

<h4>Mentor</h4>

<p>
<a href="mailto:lneto@NetBSD.org">Lourival Vieira Neto</a>
</p>

<br><hr>
<h3 id="cgilua">Adapt CGILua SAPI launcher to explore all WSAPI features.</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://keplerproject.github.io/cgilua/">
CGILua</a> is a tool for creating dynamic Web pages and manipulating input
data from Web forms.  One of advantages of CGILua is its abstraction
of the underlying Web server. CGILua can be used with a variety of Web
servers and, for each server, with different launchers. A launcher is
responsible for the interaction of CGILua and the Web server, for example
using ISAPI on IIS or mod_lua on Apache. The reference implementation
of CGILua launchers is Kepler.</p>

<p> <a href="http://keplerproject.github.io/wsapi/">WSAPI</a>
is an API that abstracts the web server from Lua web
applications. WSAPI provides a set of helper libraries that help with
request processing and output buffering.</p>

<p>Actually CGILua has an implementation of an abstract underlying server
which is almost the same of WSAPI itself. This project proposes a
reimplementation of this layer (called SAPI) to explore WSAPI fully. This
should improve the performance and simplify maintenance.</p>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Rewrite CGILua library to dispense SAPI module and use WSAPI directly.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>Advanced Lua programming is mandatory, since both tools (CGILua and WSAPI)
are not naive software. A good understanding of the Lua environment
concept is particularly necessary in this project.</p>

<p>Web programming experience can be very helpful especially to understand
the context of use of these tools.</p>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<p>Tomás Guisasola</p>

<br><hr>
<h3 id="luasql">Add support for prepared statements in LuaSQL</h3>
<h4 id="briefexplanation">Brief explanation</h4>
<p><a href="http://www.keplerproject.org/luasql/">
LuaSQL</a> is a generic interface from Lua to a DBMS.
It aims at portability over performance, but it allows extensions to
suit the particularities of each DBMS.</p>

<p>The inclusion of support for prepared statements in LuaSQL has been
discussed thoroughly some time ago, but since each DBMS offers very
different APIs there is no standard that could be defined to assure
portability between them.
Anyway the demand persists.</p>

<p>This project proposes the addition of a minimal API that would allow
each driver to implement prepared statements according to its DBMS
restrictions.</p>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Adapt the API to each LuaSQL driver according to its particularities</li>
<li>Implement the new functions to each driver</li>
<li>Test and document everything</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>C, Lua and C API for Lua:</p>

<ul>
<li>C is mandatory.</li>
<li>Knowledge of the C API for Lua is mandatory, although it is not too
difficult to be learned during the project.</li>
<li>Basic programming in Lua is very helpful, but not mandatory, since
the examples and test-cases are very simple.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>
<p>Tomás Guisasola</p>

<br/><hr/>

<h3 id="peg">Improving the Quality of Error Messages in PEG Parsers</h3>

<h4>Brief explanation</h4>

<p>
<a href="http://bford.info/pub/lang/peg">Parsing Expression Grammars</a> (PEGs)
are an expressive formalism for designing and implementing top-down parsers with local backtracking.
An issue that users of PEG-based parsers face is poor reporting of syntax errors on the part of PEG-based parsers.
<a href="http://www.inf.puc-rio.br/~roberto/docs/sblp2013-1.pdf">Labeled failures</a> are an extension to PEGs that aims
to address this issue by annotating a PEG with labels corresponding to syntax errors,
improving the quality of error messages generated by a PEG-based parser.
</p>

<p>
<a href="https://github.com/sqmedeiros/lpeglabel/">LPegLabel</a> is an extension of the
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a> tool that provides an implementation of PEGs with labeled failures. 
Labels can be used to signal different kinds of errors and to specify which alternative in a labeled ordered choice
should handle a given label. 
</p>

<p>The goal of this project is to rewrite the parsers of some Lua libraries,
such as the module <i>re</i> from LPeg and <i>lua-parser</i>, by using LPegLabel.
After this rewriting we should get parsers with better error messages.
</p>


<h4>Tools</h4>

<p>
<ul>
  <li><a href="https://github.com/sqmedeiros/lpeglabel/">LPegLabel</a>
  <li><a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a>
  <li>Lua libraries whose parsers will be rewritten
</ul> 
</p>


<h4>Expected results</h4>

<p>
<ul>
  <li>The rewriting of at least 3 parsers by using LPegLabel
  <li>A proper documentation
</ul>
</p>

<p>
A marginal result would be the improvement of the LPegLabel tool
based on the difficulties found during the project.
</p>


<h4>Prerequisites</h4>

<p>
We expect the applicants to know <b>parsing</b> well and
to develop familiarity with LPeg and LPegLabel before the project starts.
</p>

<p>
For this reason, we may ask the applicants to perform some activities
<b>before</b> the application period.
</p>


<h4>How to apply</h4>

<p>
<ul>
<li>Get in touch.
<li>Follow the official GSoC instructions.
<li>Follow the LabLua instructions.
</ul>
</p>


<h4>Skill level</h4>

<p>
Medium
</p>


<h4>Mentor</h4>

<p>
<a href="https://sites.google.com/site/sqmedeiros/">S&eacute;rgio Medeiros</a>
</p>

<br><hr>
<h3 id="lad">Assembler and Disassembler for Lua 5.3</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p>
Lua is a dynamically typed programming language that runs by interpreting
bytecode for a register-based machine.
More precisely, Lua programs are interpreted indirectly from source code,
that is, they are compiled to bytecode and then executed by the Lua Virtual Machine.
This process is done during code execution and it is transparent to final users.
</p>

<p>
The aim of this project is to create a disassembler and an assembler for Lua 5.3.
The disassembler should generate assembly code from either Lua code or
bytecode, while the the assembler ought to generate Lua bytecode from
assembly code.
The assembly syntax should be expressive enough to encode all the instructions
that are available at Lua VM.
</p>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>A disassembler script that converts Lua code/bytecode into assembly instructions.</li>
<li>An assembler script that converts assembly instructions into executable Lua bytecode.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
<li>Lua (the project should be written in Lua).</li>
<li>C (it is important to read the implementation of Lua VM).</li>
<li>Git (the project repository should be in github).</li>
<li>LPeg is a plus (the assembler parser can be written with LPeg).</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Easy</p>

<h4 id="mentor">Mentor</h4>
<p>
<a href="mailto:amaidl@inf.puc-rio.br">André Murbach Maidl</a>
</p>

<br><hr>

<h3 id="typedlua">Add class-based object-oriented programming to <a href="https://github.com/andremm/typedlua">Typed Lua</a></h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Typed Lua is a strict superset of Lua that provides optional
type annotations, and compile-time type checking.
More precisely, Typed Lua is implemented as a programming language
that extends Lua syntax to add optional type annotations.
The compiler uses static types to perform compile-time type checking,
but also allows Lua code to coexist with Typed Lua code, and generate
Lua code that runs in unmodified Lua implementations.</p>

<h4 id="expectedresults">Expected results</h4>

<p>Typed Lua intended use is as an application language, and we view that
policies for organizing a program in modules and writing object-oriented
programs should be part of the language and enforced by its optional type
system. An application language is a programming language that helps
programmers develop applications from scratch until these applications
evolve to complex systems rather than just scripts.
This project aims to add class-based object-oriented programming to
Typed Lua through the definition of classes and interfaces,
as a way to help Lua programmers better structure their code.
The backend code generator should be a plugin, so the programmers
can choose which OO style or library they want to use.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<p>Lua, Object-Oriented Programming, and Type Systems</p>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p><a href="http://www.dcc.ufrj.br/~fabiom/">Fabio Mascarenhas</a></p>

<!--
<li><a href="#kerneltest">
Port Lua Test Suite to NetBSD Kernel
</a></li>
<li><a href="#elastic">
Elasticsearch Lua client (elasticsearch-lua)
</a></li>
<li><a href="#lpeg">
Add support for left recursion to LPeg
</a></li>
<li><a href="#luasoap">
Add support for WSDL generation to LuaSOAP
</a></li>
<li><a href="#vlc">
Multi-CPU usage in VLC
</a></li>
<li><a href="#wireshark">
Multi-CPU usage in wireshark
</a></li>
<li><a href="#dynserial">
Develop a binary serialization format with support for dynamically types values and an RPC protocol for dynamically typed invocations based on this format.
</a></li>
<li><a href="#loski">
Develop a library for Lua that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.
</a></li>
<li><a href="#ceu">
Port an SDL-based C++ open source game to Céu
</a></li>
</ul>
-->


<!--

<br><hr>
<h3 id="kerneltest">Port Lua Test Suite to NetBSD Kernel</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p>
<a href="http://www.netbsd.org">The NetBSD Operating System</a>
has a kernel-level Lua interpreter version for
<a href="http://netbsd.org/~lneto/dls14.pdf">scripting its kernel</a>.
For example, it allows users to
<a href="http://netbsd.org/~lneto/eurobsdcon14.pdf">filter packets using Lua
scripts</a>.
<p>
The main difference between kernel Lua and regular user-level Lua
is that kernel Lua doesn't have support for standard libraries that depend on
operating system (e.g., io and os) and for floating-point numbers.
The purpose of this project is to port
the <a href="http://www.lua.org/tests/">Lua Test Suite</a>
to NetBSD kernel.
That is,
to adapt scripts from Lua test suite and
develop a <a
href="http://www.home.unix-ag.org/bmeurer/NetBSD/howto-lkm.html">NetBSD
loadable kernel module</a> containing the C portion of Lua test suite.

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Adapted test scripts for kernel Lua</li>
<li>Kernel module for testing the
<a href="http://www.lua.org/manual/5.3/manual.html#4">Lua C API</a></li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>C, Lua (and some patience :) )
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<a href="mailto:lourival.neto@gmail.com">Lourival Vieira Neto</a>
<p>
<br><hr>
<h3 id="elastic">Elasticsearch Lua client (elasticsearch-lua)</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://elasticsearch.com/">Elasticsearch</a>
is a distributed and scalable search engine.
It is written in Java and, besides the transport protocol (Java to
Java), it offers a very complete REST API accessed through
<a href="http://json.org/">JSON</a></p>

<p>Elasticsearch clients for different scripting languages such as Python, PHP
and Perl have already been developed.
However, a client for <a href="http://lua.org/">Lua</a>
is still not available.

<p>This project aims to create a complete Lua client to access Elasticsearch.


<h4 id="expectedresults">Expected results</h4>
<ul>
<li>A complete Lua client to access the Elasticsearch REST API.
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>Lua - medium (socket and metatable experience is important)
<li>Elasticsearch - basic/medium
<li>JSON - medium
<li>HTTP - basic/medium
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>
<p><a href="http://www.inf.puc-rio.br/~pmusa/">Pablo Musa</a></p>




<br><hr>
<h3 id="luasoap">Add support for WSDL generation to LuaSOAP</h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p><a href="http://tomasguisasola.github.io/luasoap/">LuaSOAP</a> is a library to
ease the use of <a href="http://www.w3.org/TR/soap/">SOAP</a>.  LuaSOAP provides
a very simple API that convert Lua tables to and from XML documents.
It also offers a simple way to invoke remote Web Services without having
to deal directly with SOAP messages.  In fact, LuaSOAP also provides
a simple way to offer Web Services -- the server side -- but it lacks
support for WSDL generation of the offered services.</p>

<p><a href="http://www.w3.org/TR/wsdl">WSDL</a> is an XML format for describing
network services.  It is used to describe operations and messages --
with its types -- offered by Web Services.  Since Lua code does not
include type information, automatic generation has to be based on some
kind of hand-made declarative information.</p>

<h4 id="expectedresults">Expected results</h4>
<ul>
<li>Define the format to describe complementary WSDL information in Lua</li>
<li>Implement an automatic generator of WSDL documents</li>
<li>Test and document everything</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>Lua programming; client-server web architecture; SOAP and WSDL specifications.</p>

<ul>
<li>Basic programming in Lua is mandatory</li>
<li>Web programming experience is very appreciated but not mandatory</li>
<li>SOAP and WSDL specifications could be learned during the project</li>
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Tomás Guisasola</p>


<br><hr>
<h3 id="vlc">Multi-CPU usage in VLC</h3>
<h4 id="briefexplanation">Brief explanation:</h4>

<p><a href="https://wiki.videolan.org/VLC_media_player/">VLC </a> is a free and open source cross-platform multimedia player and framework that plays most multimedia files as well as DVD, Audio CD, VCD, and various streaming protocols. Lua scripts can be added to VLC for tasks such as playlist construction and service discovery. Such tasks may involve a lot of parsing and communication and could benefit from using multiple CPUs when available. The purpose of this project is to include support for multi-CPU usage in VLC, using
<a href="http://askyrme.github.io/luaproc/">luaproc</a>,
 a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4 id="expectedresults">Expected results:</h4>
<p>Multi-CPU support in VLC.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>
<p>C, Lua</p>

<h4 id="skilllevel">Skill level:</h4>
<p>Medium</p>

<h4 id="mentor">Mentor:</h4>
<p>Alexandre Skyrme</p>

<br><hr>
<h3 id="wireshark">Multi-CPU usage in wireshark</h3>
<h4 id="briefexplanation">Brief explanation:</h4>

<p>The 
<a href="http://www.wireshark.org/">
wireshark network protocol analyser</a> allows programmers to use Lua to write dissectors, post-dissectors and taps. Dissectors are protocol analysers, while post-dissectors are executed after all others dissectors, and taps are used to collect information after packet dissection. Protocol dissection can involve time constraints, and it would be nice to benefit from multi-CPU processing power in dissector script. The purpose of this project is to include support for multi-CPU usage in wireshark, using 
<a href="http://askyrme.github.io/luaproc/">luaproc</a>,
a library that allows programmers to create multiple independent execution flows of Lua code that can run inparallel, communicating only via message-passing.</p>

<h4 id="expectedresults">Expected results:</h4>
<p>We expect the support for Multi-CPU usage in wireshark.</p>

<h4 id="knowledgeprerequisite">Knowledge prerequisite:</h4>
<p>C, Lua</p>

<h4 id="skilllevel">Skill level:</h4>
<p>Medium</p>

<h4 id="mentor">Mentor:</h4>
<p>Alexandre Skyrme</p>


<br><hr>
<h3 id="lpeg">Add support for left recursion to 
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/">
LPeg</a></h3>
<h4 id="briefexplanation">Brief explanation</h4>

<p>Parsing Expression Grammars (PEGs) are an expressive formalism for designing
and implementing top-down parsers with local backtracking. A frequently missed 
feature of PEGs is left recursion, which is commonly used in 
Context-Free Grammars (CFGs) to encode left-associative operations.

<p>There is a 
<a href="http://arxiv.org/pdf/1207.0443.pdf">
formal extension to the PEGs formalism</a>
that allows the use of 
left-recursive rules in a PEG grammar and that was implemented by 
some PEG-based tools, such as
<a href="https://github.com/sacek/LPegLJ">LPegLJ  </a>
and <a href="http://ironmeta.sourceforge.net/">IronMeta</a>.

<p>The aim of this project is to create a fork of
<a href="http://www.inf.puc-rio.br/~roberto/lpeg/">LPeg</a>,
an implementation of PEGs for Lua based on a virtual parsing machine.

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<p>C, Lua and Parsing Expression Grammars

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>
<p><a href="https://sites.google.com/site/sqmedeiros/">Sérgio Medeiros</a></p>

<br><hr>
<h3 id="dynserial">Develop a binary serialization format with support for dynamically types values and an RPC protocol for dynamically typed invocations based on this format.</h3>

<h4 id="briefexplanation">Brief explanation</h4>

<p>Most RMI protocols available today are either focused on inefficient 
representation formats for typing information (e.g.
<a href="http://www.omg.org/spec/CORBA/3.3/Interoperability/PDF">
GIOP/IIOP (CORBA)</a>,
<a href="http://hessian.caucho.com">Hessian</a>,
<a href="https://developers.google.com/protocol-buffers/">
Google Protocol Buffers</a>)
or on invocations where the typing information are predefined and static, 
therefore are absent on the data sent through the wire 
(e.g.
<a href="http://www.w3.org/TR/soap/">SOAP</a>,
<a href="http://www.json.org">JSON</a>,
<a href="http://www.caucho.com/resin-3.0/protocols/burlap.xtp">Burlap</a>).
<p>
Few protocols are designed to work efficiently with typed data. Invocations with typed data work well with the RPC model because it allows the identification of deployment problems (mismatch interfaces) and facilitate the dynamic evolution of distributed systems. A protocol for dynamically typed RPC should be based on a efficient serialization format for typed data, that is, information about how the data should be interpreted.</p>

<p>The goal of this project is to design and implement a serialization binary serialization format with the following requirements:</p>

<ul>
<li>Primitive data: numeric formats (integer and floating-point), characters and boolean.</li>
<li>Structured data: serialization of usual structured data like records, arrays, maps, tuples, union, etc.</li>
<li>Optional typing: serialization of both raw data and data plus typing information.</li>
<li>Structural compatibility: type information should allow to efficiently verify whether two types are compatibile.</li>
<li>Opaque data: allow that a special form of raw data (without typing information) can be ignored without compromising the remains of the stream and that can also be passed along by a receiver that did not interpreted it.</li>
<li>Semantic information: data types that can extend a standard type with additional semantic information, like a string (sequence of characteres) with an associated charset or a record with an associated class name that provides some behavior over the data on the record.</li>
<li>Graphs: data with cyclic references.</li>
</ul>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>An specification of a binary serialization format with support for typed data.</li>
<li>An implementation of a library for encoding values using this format.</li>
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
<li>Programming in C (medium to advanced).</li>
<li>Familiarity with concepts of the Lua language.</li>
<li>Data structures and formats (endianess, two's complement, IEEE 754, memory pointes, etc).
<li>Network protocols fundamentals.
</ul>

<h4 id="skilllevel">Skill level</h4>

<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Renato Maia</p>

<br><hr>
<h3 id="loski">Develop a library for Lua 
that allows Lua programs to access features provided by the platform's underlying operating system (OS) kernel, such as process control, network access, file system, event notification, etc.</h3>

<h4 id="briefexplanation">Brief explanation</h4>
<p>Standard Lua distribution is based mostly on standard ANSI C libraries only. Therefore, many functionalities provided by modern platforms (like process control, file system operations, network communication, kernel event notification, etc.) are only available through third-party libraries that are developed independently and might not integrate.</p>

<p>The project has three main goals:</p>

<ul>
<li>Design a simple and easy API that allows for different implementations over various platforms (POSIX, Linux, MacOSX, Windows, etc.) yet allowing use of a basic set of features that are provided by most popular plataforms.</li>
<li>Design an internal architecture that facilitate the replacement of the actual implementation of the features provided by the library (create process, use sockets, inspect file systems, etc). This is important to make porting the library to other platoforms easier.</li>
<li>Provide a basic/standard implementation of features provided by the library based on the codebase of existing Lua libraries that already export features of the underlying platform like 
<a href="http://w3.impa.br/~diego/software/luasocket/">LuaSocket</a>,
<a href="http://keplerproject.github.io/luafilesystem/">
LuaFileSystem</a> and others.</li>
</ul>

A prototype for the proposed library is available 
<a href="https://github.com/renatomaia/loski">
here</a>.

<h4 id="expectedresults">Expected results</h4>

<p>A set of Lua libraries implemented at least in one major operating system platform. The library shall provide support for:</p>

<ul>
<li>Creation and manipulation of processes, and possibly inter-process comunication mechanisms, such as pipes.</li>
<li>Creation and maniputation of sockets (TCP and UDP).</li>
<li>Inspection of the local file system, possibly including file attributes and permissions.</li>
<li>Notification of kernel events like process termination, socket data availability, file modification, etc.</li>
</ul>

<p>The implementation shall also be flexible enough to facilitate the portability for other platforms.</p>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>
<ul>
<li>Programming in C.</li>
<li>Familiarity with concepts of the Lua language.</li>
<li>Programming with the system API of some popular platform, such as Linux, FreeBSD, Windows, etc.</li>
</ul>

<h4 id="skilllevel">Skill level</h4>
<p>Hard</p>

<h4 id="mentor">Mentor</h4>

<p>Renato Maia</p>


<br><hr>
<h3 id="ceu">
Port an SDL-based C++ open source game to Céu
</h3>

<h4 id="about-ceu">
About Céu
</h4>

Céu is a programming language that targets system-level development of reactive 
systems.
<p>
For a little introduction about the language, please watch the video in our front page:
<br>
<a href="http://ceu-lang.org/">
http://ceu-lang.org/
</a>
<p>
Céu appeared last year on "StrangeLoop" and the "Future Programming Workshop":
<br>
<a href="http://www.future-programming.org/program.html">
http://www.future-programming.org/program.html
</a>

<h4 id="briefexplanation">Brief explanation</h4>

Port to Céu an existing C++ open source game of considerable size (30-50k lines of code).
<p>
Here are some possible projects to look for:
<ul>
<li>
<a href="http://en.wikipedia.org/wiki/List_of_open-source_video_games">
http://en.wikipedia.org/wiki/List_of_open-source_video_games
</a>
<li>
<a href="http://www.reddit.com/r/opensourcegames">
http://www.reddit.com/r/opensourcegames
</a>
</ul>

<h4 id="expectedresults">Expected results</h4>

<ul>
<li>A working implementation of the game
<li>A report about the experience of using Céu in the context of game 
development, also comparing the implementations in terms of code complexity 
(e.g., lines of code), resource usage (CPU, memory), etc.
</ul>

<h4 id="knowledgeprerequisites">Knowledge prerequisites</h4>

<ul>
  <li> SDL
  <li> C
</ul>

<p>
(Previous experience with Céu is of course not required.)

<p>
Linux, Mac or Windows?
<p>
The current distribution of Céu is only available for Linux.
<br>
A student using another operating system is also welcome, as long as she/he has 
the skills to build the development environment by her/himself.
<br>
The compiler of Céu depends on gcc, lua-5.1, and lua-lpeg.

<h4 id="recommendations">Recommendations</h4>

Last year LabLua had over 15 submissions for only 4 slots.
<br>
(Note that we will only know the number of slots for this year <b>after</b> the 
students submit the proposals.)

<p>
It is highly recommended that the student installs Céu, compiles some examples, 
possibly making something very simple from scratch (or changing some existing 
example).
<br>
For us, this is important to see if the student will be able to keep track of the project.
<br>
For the student, this initial experience is important to ensure that the 
expectations with the project match the reality.

<p>
If the student has participated in other open source projects, it is also 
recommended that she/he tell us about that experience

<h4 id="skilllevel">Skill level</h4>
<p>Medium</p>

<h4 id="mentor">Mentor</h4>

<p>Francisco Sant'Anna</p>

-->
